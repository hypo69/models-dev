Task: You are a QA engineer. Your task is to write pytest test cases for a Python module that handles file operations. The module includes functions for saving text to a file, reading text from a file, and getting filenames and directory names from a specified directory. Your tests should cover a variety of scenarios, including edge cases, and should ensure that each function behaves as expected. Pay special attention to handling errors and different file extensions. Requirements: Write pytest test cases for each of the functions (save_text_file, read_text_file, get_filenames, and get_directory_names). Test the functions with different data types, including lists, strings, and dictionaries. Ensure to cover edge cases like non-existing paths, empty directories, and files with unusual extensions. Simulate various scenarios where exceptions might be raised and verify that the error logging is handled correctly. Use mocking to avoid actual file system operations where appropriate. Ensure that the test functions are well-structured and that each test is independent of the others. Here's an example of a pytest test case for one of the functions (save_text_file) from the provided module. The test case uses mocking to avoid actual file system operations: import pytest from unittest.mock import patch, mock_open, MagicMock from pathlib import Path from src.utils.file.file import save_text_file @patch('src.utils.file.file.Path.open', new_callable=mock_open) @patch('src.utils.file.file.Path.mkdir') @patch('src.utils.file.file.logger') def test_save_text_file(mock_logger, mock_mkdir, mock_file_open): """Test saving text to a file.""" file_path = '/path/to/your/file.txt' data = "Hello, world!" result = save_text_file(data, file_path) mock_mkdir.assert_called_once_with(parents=True, exist_ok=True) mock_file_open.assert_called_once_with('w') mock_file_open().write.assert_called_once_with(data) assert result is True data_list = ["line 1", "line 2", "line 3"] result = save_text_file(data_list, file_path) mock_file_open().write.assert_called_with(f"{data_list[0]}\n") assert mock_file_open().write.call_count == len(data_list) assert result is True mock_file_open.side_effect = Exception("Mocked exception") result = save_text_file(data, file_path) mock_logger.error.assert_called_once() assert result is False Explanation: Mocks and Patches: The @patch decorators are used to mock the Path.open, Path.mkdir, and logger functions so that no actual file system operations are performed. mock_open is used to simulate the file opening and writing operations. Test Cases: Saving a String: The function is called with a string as the data. Assertions check that mkdir was called to create parent directories, the file was opened with the correct mode, and the content was written correctly. Saving a List of Strings: The function is called with a list of strings. The test asserts that each line is written to the file individually. Exception Handling: The side_effect attribute of mock_file_open is used to simulate an exception during the file operation. The test asserts that the logger's error method was called and that the function returned False. Running the Test: To run the test, ensure that pytest is installed and then run the following command in the terminal: pytest path_to_test_file.py This example should give you a solid starting point to write additional tests for the other functions in the module.